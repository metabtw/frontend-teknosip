"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./context/AuthContext.tsx":
/*!*********************************!*\
  !*** ./context/AuthContext.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthContext: () => (/* binding */ AuthContext),\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _utils_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/api */ \"(app-pages-browser)/./utils/api.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthContext,AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    // Token geçerliliğini kontrol et\n    const isTokenValid = ()=>{\n        const token = localStorage.getItem('accessToken');\n        if (!token) return false;\n        try {\n            const payload = JSON.parse(atob(token.split('.')[1]));\n            const currentTime = Date.now() / 1000;\n            return payload.exp > currentTime;\n        } catch (e) {\n            return false;\n        }\n    };\n    // Kullanıcı bilgilerini token'dan çıkar\n    const getUserFromToken = (token)=>{\n        try {\n            const payload = JSON.parse(atob(token.split('.')[1]));\n            console.log('Token payload:', payload);\n            // Role mapping: Backend'den gelen sayısal değerleri map et\n            let role = payload.role;\n            console.log('Original role from token:', role, 'Type:', typeof role);\n            // Hem sayısal hem string değerleri frontend rol isimlerine map et\n            switch(role){\n                case 1:\n                case 'SuperAdmin':\n                    role = 'super-admin'; // Backend: SuperAdmin=1 veya 'SuperAdmin'\n                    break;\n                case 2:\n                case 'Admin':\n                    role = 'company-admin'; // Backend: Admin=2 veya 'Admin'\n                    break;\n                case 3:\n                case 'User':\n                    role = 'employee'; // Backend: User=3 veya 'User'\n                    break;\n                default:\n                    role = 'unknown';\n            }\n            console.log('Mapped role:', role);\n            const user = {\n                id: payload.nameid || payload.sub || payload.userId,\n                name: payload.name || (payload.given_name && payload.family_name ? payload.given_name + ' ' + payload.family_name : 'Kullanıcı'),\n                email: payload.email,\n                role: role,\n                companyId: payload.companyId,\n                companyName: payload.companyName,\n                position: payload.position,\n                permissions: payload.permissions ? payload.permissions.split(',') : []\n            };\n            console.log('Final user object:', user);\n            return user;\n        } catch (error) {\n            console.error('Error parsing token:', error);\n            return null;\n        }\n    };\n    // Refresh token ile yeni access token al\n    const refreshToken = async ()=>{\n        const refreshTokenValue = localStorage.getItem('refreshToken');\n        if (!refreshTokenValue) return false;\n        try {\n            const response = await fetch(\"\".concat(\"http://localhost:5071/api\" || 0, \"/Auth/RefreshToken\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    refreshToken: refreshTokenValue\n                })\n            });\n            if (response.ok) {\n                const data = await response.json();\n                localStorage.setItem('accessToken', data.data.accessToken);\n                localStorage.setItem('refreshToken', data.data.refreshToken);\n                const userData = getUserFromToken(data.data.accessToken);\n                if (userData) {\n                    setUser(userData);\n                    return true;\n                }\n            }\n        } catch (error) {\n            console.error('Token refresh failed:', error);\n        }\n        return false;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            const initAuth = {\n                \"AuthProvider.useEffect.initAuth\": async ()=>{\n                    const token = localStorage.getItem('accessToken');\n                    if (token) {\n                        if (isTokenValid()) {\n                            const userData = getUserFromToken(token);\n                            if (userData) {\n                                setUser(userData);\n                            }\n                        } else {\n                            // Token süresi dolmuş, refresh token dene\n                            const refreshed = await refreshToken();\n                            if (!refreshed) {\n                                // Refresh token da başarısız, logout yap\n                                localStorage.removeItem('accessToken');\n                                localStorage.removeItem('refreshToken');\n                                router.push('/auth/login');\n                            }\n                        }\n                    }\n                    setLoading(false);\n                }\n            }[\"AuthProvider.useEffect.initAuth\"];\n            initAuth();\n        }\n    }[\"AuthProvider.useEffect\"], [\n        router\n    ]);\n    const login = async (email, password)=>{\n        try {\n            setLoading(true);\n            // API'ye login isteği gönder\n            const response = await (0,_utils_api__WEBPACK_IMPORTED_MODULE_3__.loginUser)(email, password);\n            if (response.isSuccess && response.accessToken && response.refreshToken) {\n                // Token'ları localStorage'a kaydet\n                localStorage.setItem('accessToken', response.accessToken);\n                localStorage.setItem('refreshToken', response.refreshToken);\n                // Token'dan kullanıcı bilgilerini çıkar\n                const userData = getUserFromToken(response.accessToken);\n                if (userData) {\n                    setUser(userData);\n                    // Role based routing\n                    switch(userData.role){\n                        case 'super-admin':\n                            router.push('/admin/dashboard');\n                            break;\n                        case 'company-admin':\n                            router.push('/company-admin/dashboard');\n                            break;\n                        case 'employee':\n                            router.push('/employee/dashboard');\n                            break;\n                        case 'unknown':\n                            throw new Error('Tanımlanmamış kullanıcı rolü. Lütfen sistem yöneticisi ile iletişime geçin.');\n                        default:\n                            throw new Error(\"Ge\\xe7ersiz kullanıcı rol\\xfc: \".concat(userData.role));\n                    }\n                } else {\n                    throw new Error('Kullanıcı bilgileri alınamadı');\n                }\n            } else {\n                throw new Error(response.message || 'Giriş başarısız');\n            }\n        } catch (error) {\n            console.error('Login error:', error);\n            throw new Error(error.message || 'Giriş sırasında bir hata oluştu');\n        } finally{\n            setLoading(false);\n        }\n    };\n    const logout = ()=>{\n        setUser(null);\n        localStorage.removeItem('accessToken');\n        localStorage.removeItem('refreshToken');\n        router.push('/auth/login');\n    };\n    const registerCompany = async (companyData)=>{\n        try {\n            const result = await (0,_utils_api__WEBPACK_IMPORTED_MODULE_3__.registerCompany)(companyData);\n            return result;\n        } catch (error) {\n            throw new Error(error.message || 'Şirket kaydı sırasında bir hata oluştu');\n        }\n    };\n    const addEmployee = async (employeeData)=>{\n        // Mock employee registration\n        return new Promise((resolve, reject)=>{\n            if (!user || user.role !== 'company-admin') {\n                reject(new Error('Çalışan ekleme yetkisi yok'));\n                return;\n            }\n            setTimeout(()=>{\n                const newEmployee = {\n                    id: \"emp-\".concat(Date.now()),\n                    name: employeeData.name,\n                    email: employeeData.email,\n                    role: 'employee',\n                    companyId: user.companyId,\n                    companyName: user.companyName,\n                    position: employeeData.position,\n                    permissions: employeeData.permissions\n                };\n                console.log('Çalışan eklendi:', newEmployee);\n                resolve();\n            }, 1500);\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            login,\n            logout,\n            registerCompany,\n            addEmployee,\n            loading,\n            isTokenValid,\n            refreshToken\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\muham\\\\OneDrive\\\\Desktop\\\\teknozip\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 277,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"J17Kp8z+0ojgAqGoY5o3BCjwWms=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvQXV0aENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFa0Y7QUFDdEM7QUFDbUM7QUFvRHhFLE1BQU1RLDRCQUFjUixvREFBYUEsQ0FBOEJTLFdBQVc7QUFFMUUsTUFBTUMsZUFBZTtRQUFDLEVBQUVDLFFBQVEsRUFBMkI7O0lBQ2hFLE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHWCwrQ0FBUUEsQ0FBYztJQUM5QyxNQUFNLENBQUNZLFNBQVNDLFdBQVcsR0FBR2IsK0NBQVFBLENBQUM7SUFDdkMsTUFBTWMsU0FBU1osMERBQVNBO0lBRXhCLGlDQUFpQztJQUNqQyxNQUFNYSxlQUFlO1FBQ25CLE1BQU1DLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxJQUFJLENBQUNGLE9BQU8sT0FBTztRQUVuQixJQUFJO1lBQ0YsTUFBTUcsVUFBVUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLTixNQUFNTyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDbkQsTUFBTUMsY0FBY0MsS0FBS0MsR0FBRyxLQUFLO1lBQ2pDLE9BQU9QLFFBQVFRLEdBQUcsR0FBR0g7UUFDdkIsRUFBRSxVQUFNO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQSx3Q0FBd0M7SUFDeEMsTUFBTUksbUJBQW1CLENBQUNaO1FBQ3hCLElBQUk7WUFDRixNQUFNRyxVQUFVQyxLQUFLQyxLQUFLLENBQUNDLEtBQUtOLE1BQU1PLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNuRE0sUUFBUUMsR0FBRyxDQUFDLGtCQUFrQlg7WUFFOUIsMkRBQTJEO1lBQzNELElBQUlZLE9BQU9aLFFBQVFZLElBQUk7WUFDdkJGLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkJDLE1BQU0sU0FBUyxPQUFPQTtZQUUvRCxrRUFBa0U7WUFDbEUsT0FBUUE7Z0JBQ04sS0FBSztnQkFDTCxLQUFLO29CQUNIQSxPQUFPLGVBQWdCLDBDQUEwQztvQkFDakU7Z0JBQ0YsS0FBSztnQkFDTCxLQUFLO29CQUNIQSxPQUFPLGlCQUFrQixnQ0FBZ0M7b0JBQ3pEO2dCQUNGLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSEEsT0FBTyxZQUFhLDhCQUE4QjtvQkFDbEQ7Z0JBQ0Y7b0JBQ0VBLE9BQU87WUFDWDtZQUVBRixRQUFRQyxHQUFHLENBQUMsZ0JBQWdCQztZQUU1QixNQUFNckIsT0FBTztnQkFDWHNCLElBQUliLFFBQVFjLE1BQU0sSUFBSWQsUUFBUWUsR0FBRyxJQUFJZixRQUFRZ0IsTUFBTTtnQkFDbkRDLE1BQU1qQixRQUFRaUIsSUFBSSxJQUFLakIsQ0FBQUEsUUFBUWtCLFVBQVUsSUFBSWxCLFFBQVFtQixXQUFXLEdBQUduQixRQUFRa0IsVUFBVSxHQUFHLE1BQU1sQixRQUFRbUIsV0FBVyxHQUFHLFdBQVU7Z0JBQzlIQyxPQUFPcEIsUUFBUW9CLEtBQUs7Z0JBQ3BCUixNQUFNQTtnQkFDTlMsV0FBV3JCLFFBQVFxQixTQUFTO2dCQUM1QkMsYUFBYXRCLFFBQVFzQixXQUFXO2dCQUNoQ0MsVUFBVXZCLFFBQVF1QixRQUFRO2dCQUMxQkMsYUFBYXhCLFFBQVF3QixXQUFXLEdBQUd4QixRQUFRd0IsV0FBVyxDQUFDcEIsS0FBSyxDQUFDLE9BQU8sRUFBRTtZQUN4RTtZQUVBTSxRQUFRQyxHQUFHLENBQUMsc0JBQXNCcEI7WUFDbEMsT0FBT0E7UUFDVCxFQUFFLE9BQU9rQyxPQUFPO1lBQ2RmLFFBQVFlLEtBQUssQ0FBQyx3QkFBd0JBO1lBQ3RDLE9BQU87UUFDVDtJQUNGO0lBRUEseUNBQXlDO0lBQ3pDLE1BQU1DLGVBQWU7UUFDbkIsTUFBTUMsb0JBQW9CN0IsYUFBYUMsT0FBTyxDQUFDO1FBQy9DLElBQUksQ0FBQzRCLG1CQUFtQixPQUFPO1FBRS9CLElBQUk7WUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sR0FBa0UsT0FBL0RDLDJCQUErQixJQUFJLENBQTJCLEVBQUMsdUJBQXFCO2dCQUNsSEcsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNbEMsS0FBS21DLFNBQVMsQ0FBQztvQkFBRVYsY0FBY0M7Z0JBQWtCO1lBQ3pEO1lBRUEsSUFBSUMsU0FBU1MsRUFBRSxFQUFFO2dCQUNmLE1BQU1DLE9BQU8sTUFBTVYsU0FBU1csSUFBSTtnQkFDaEN6QyxhQUFhMEMsT0FBTyxDQUFDLGVBQWVGLEtBQUtBLElBQUksQ0FBQ0csV0FBVztnQkFDekQzQyxhQUFhMEMsT0FBTyxDQUFDLGdCQUFnQkYsS0FBS0EsSUFBSSxDQUFDWixZQUFZO2dCQUUzRCxNQUFNZ0IsV0FBV2pDLGlCQUFpQjZCLEtBQUtBLElBQUksQ0FBQ0csV0FBVztnQkFDdkQsSUFBSUMsVUFBVTtvQkFDWmxELFFBQVFrRDtvQkFDUixPQUFPO2dCQUNUO1lBQ0Y7UUFDRixFQUFFLE9BQU9qQixPQUFPO1lBQ2RmLFFBQVFlLEtBQUssQ0FBQyx5QkFBeUJBO1FBQ3pDO1FBRUEsT0FBTztJQUNUO0lBRUEzQyxnREFBU0E7a0NBQUM7WUFDUixNQUFNNkQ7bURBQVc7b0JBQ2YsTUFBTTlDLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztvQkFFbkMsSUFBSUYsT0FBTzt3QkFDVCxJQUFJRCxnQkFBZ0I7NEJBQ2xCLE1BQU04QyxXQUFXakMsaUJBQWlCWjs0QkFDbEMsSUFBSTZDLFVBQVU7Z0NBQ1psRCxRQUFRa0Q7NEJBQ1Y7d0JBQ0YsT0FBTzs0QkFDTCwwQ0FBMEM7NEJBQzFDLE1BQU1FLFlBQVksTUFBTWxCOzRCQUN4QixJQUFJLENBQUNrQixXQUFXO2dDQUNkLHlDQUF5QztnQ0FDekM5QyxhQUFhK0MsVUFBVSxDQUFDO2dDQUN4Qi9DLGFBQWErQyxVQUFVLENBQUM7Z0NBQ3hCbEQsT0FBT21ELElBQUksQ0FBQzs0QkFDZDt3QkFDRjtvQkFDRjtvQkFFQXBELFdBQVc7Z0JBQ2I7O1lBRUFpRDtRQUNGO2lDQUFHO1FBQUNoRDtLQUFPO0lBRVgsTUFBTW9ELFFBQVEsT0FBTzNCLE9BQWU0QjtRQUNsQyxJQUFJO1lBQ0Z0RCxXQUFXO1lBRVgsNkJBQTZCO1lBQzdCLE1BQU1rQyxXQUFXLE1BQU01QyxxREFBU0EsQ0FBQ29DLE9BQU80QjtZQUV4QyxJQUFJcEIsU0FBU3FCLFNBQVMsSUFBSXJCLFNBQVNhLFdBQVcsSUFBSWIsU0FBU0YsWUFBWSxFQUFFO2dCQUN2RSxtQ0FBbUM7Z0JBQ25DNUIsYUFBYTBDLE9BQU8sQ0FBQyxlQUFlWixTQUFTYSxXQUFXO2dCQUN4RDNDLGFBQWEwQyxPQUFPLENBQUMsZ0JBQWdCWixTQUFTRixZQUFZO2dCQUUxRCx3Q0FBd0M7Z0JBQ3hDLE1BQU1nQixXQUFXakMsaUJBQWlCbUIsU0FBU2EsV0FBVztnQkFFdEQsSUFBSUMsVUFBVTtvQkFDWmxELFFBQVFrRDtvQkFFUixxQkFBcUI7b0JBQ3JCLE9BQVFBLFNBQVM5QixJQUFJO3dCQUNuQixLQUFLOzRCQUNIakIsT0FBT21ELElBQUksQ0FBQzs0QkFDWjt3QkFDRixLQUFLOzRCQUNIbkQsT0FBT21ELElBQUksQ0FBQzs0QkFDWjt3QkFDRixLQUFLOzRCQUNIbkQsT0FBT21ELElBQUksQ0FBQzs0QkFDWjt3QkFDRixLQUFLOzRCQUNILE1BQU0sSUFBSUksTUFBTTt3QkFDbEI7NEJBQ0UsTUFBTSxJQUFJQSxNQUFNLGtDQUEwQyxPQUFkUixTQUFTOUIsSUFBSTtvQkFDN0Q7Z0JBQ0YsT0FBTztvQkFDTCxNQUFNLElBQUlzQyxNQUFNO2dCQUNsQjtZQUNGLE9BQU87Z0JBQ0wsTUFBTSxJQUFJQSxNQUFNdEIsU0FBU3VCLE9BQU8sSUFBSTtZQUN0QztRQUNGLEVBQUUsT0FBTzFCLE9BQVk7WUFDbkJmLFFBQVFlLEtBQUssQ0FBQyxnQkFBZ0JBO1lBQzlCLE1BQU0sSUFBSXlCLE1BQU16QixNQUFNMEIsT0FBTyxJQUFJO1FBQ25DLFNBQVU7WUFDUnpELFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTTBELFNBQVM7UUFDYjVELFFBQVE7UUFDUk0sYUFBYStDLFVBQVUsQ0FBQztRQUN4Qi9DLGFBQWErQyxVQUFVLENBQUM7UUFDeEJsRCxPQUFPbUQsSUFBSSxDQUFDO0lBQ2Q7SUFFQSxNQUFNN0Qsa0JBQWtCLE9BQU9vRTtRQUM3QixJQUFJO1lBQ0YsTUFBTUMsU0FBUyxNQUFNcEUsMkRBQWtCQSxDQUFDbUU7WUFDeEMsT0FBT0M7UUFDVCxFQUFFLE9BQU83QixPQUFZO1lBQ25CLE1BQU0sSUFBSXlCLE1BQU16QixNQUFNMEIsT0FBTyxJQUFJO1FBQ25DO0lBQ0Y7SUFFQSxNQUFNSSxjQUFjLE9BQU9DO1FBQ3pCLDZCQUE2QjtRQUM3QixPQUFPLElBQUlDLFFBQWMsQ0FBQ0MsU0FBU0M7WUFDakMsSUFBSSxDQUFDcEUsUUFBUUEsS0FBS3FCLElBQUksS0FBSyxpQkFBaUI7Z0JBQzFDK0MsT0FBTyxJQUFJVCxNQUFNO2dCQUNqQjtZQUNGO1lBRUFVLFdBQVc7Z0JBQ1QsTUFBTUMsY0FBYztvQkFDbEJoRCxJQUFJLE9BQWtCLE9BQVhQLEtBQUtDLEdBQUc7b0JBQ25CVSxNQUFNdUMsYUFBYXZDLElBQUk7b0JBQ3ZCRyxPQUFPb0MsYUFBYXBDLEtBQUs7b0JBQ3pCUixNQUFNO29CQUNOUyxXQUFXOUIsS0FBSzhCLFNBQVM7b0JBQ3pCQyxhQUFhL0IsS0FBSytCLFdBQVc7b0JBQzdCQyxVQUFVaUMsYUFBYWpDLFFBQVE7b0JBQy9CQyxhQUFhZ0MsYUFBYWhDLFdBQVc7Z0JBQ3ZDO2dCQUNBZCxRQUFRQyxHQUFHLENBQUMsb0JBQW9Ca0Q7Z0JBQ2hDSDtZQUNGLEdBQUc7UUFDTDtJQUNGO0lBRUEscUJBQ0UsOERBQUN2RSxZQUFZMkUsUUFBUTtRQUFDQyxPQUFPO1lBQzNCeEU7WUFDQXdEO1lBQ0FLO1lBQ0FuRTtZQUNBc0U7WUFDQTlEO1lBQ0FHO1lBQ0E4QjtRQUNGO2tCQUNHcEM7Ozs7OztBQUdQLEVBQUU7R0F2T1dEOztRQUdJTixzREFBU0E7OztLQUhiTTtBQXlPTixNQUFNMkUsVUFBVTs7SUFDckIsTUFBTUMsVUFBVXJGLGlEQUFVQSxDQUFDTztJQUMzQixJQUFJOEUsWUFBWTdFLFdBQVc7UUFDekIsTUFBTSxJQUFJOEQsTUFBTTtJQUNsQjtJQUNBLE9BQU9lO0FBQ1QsRUFBRTtJQU5XRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxtdWhhbVxcT25lRHJpdmVcXERlc2t0b3BcXHRla25vemlwXFxjb250ZXh0XFxBdXRoQ29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xyXG5pbXBvcnQgeyBsb2dpblVzZXIsIHJlZ2lzdGVyQ29tcGFueSBhcyByZWdpc3RlckNvbXBhbnlBUEkgfSBmcm9tICdAL3V0aWxzL2FwaSc7XHJcblxyXG50eXBlIFVzZXIgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZW1haWw6IHN0cmluZztcclxuICByb2xlOiAnc3VwZXItYWRtaW4nIHwgJ2NvbXBhbnktYWRtaW4nIHwgJ2VtcGxveWVlJztcclxuICBjb21wYW55SWQ/OiBzdHJpbmc7XHJcbiAgY29tcGFueU5hbWU/OiBzdHJpbmc7XHJcbiAgc3RhdHVzPzogJ2FwcHJvdmVkJyB8ICdwZW5kaW5nJyB8ICdyZWplY3RlZCc7XHJcbiAgcG9zaXRpb24/OiBzdHJpbmc7XHJcbiAgcGVybWlzc2lvbnM/OiBzdHJpbmdbXTtcclxufTtcclxuXHJcbnR5cGUgQXV0aENvbnRleHRUeXBlID0ge1xyXG4gIHVzZXI6IFVzZXIgfCBudWxsO1xyXG4gIGxvZ2luOiAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2dvdXQ6ICgpID0+IHZvaWQ7XHJcbiAgcmVnaXN0ZXJDb21wYW55OiAoY29tcGFueURhdGE6IENvbXBhbnlSZWdpc3RyYXRpb24pID0+IFByb21pc2U8YW55PjtcclxuICBhZGRFbXBsb3llZTogKGVtcGxveWVlRGF0YTogRW1wbG95ZWVSZWdpc3RyYXRpb24pID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9hZGluZzogYm9vbGVhbjtcclxuICBpc1Rva2VuVmFsaWQ6ICgpID0+IGJvb2xlYW47XHJcbiAgcmVmcmVzaFRva2VuOiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xyXG59O1xyXG5cclxudHlwZSBDb21wYW55UmVnaXN0cmF0aW9uID0ge1xyXG4gIHR5cGU6IHN0cmluZztcclxuICBjb21wYW55TmFtZTogc3RyaW5nO1xyXG4gIGVtYWlsOiBzdHJpbmc7XHJcbiAgcGhvbmVOdW1iZXI6IHN0cmluZztcclxuICB0YXhOdW1iZXI6IHN0cmluZztcclxuICBpbmR1c3RyeTogc3RyaW5nO1xyXG4gIGV4cGVydGlzZUFyZWFzOiBzdHJpbmc7XHJcbiAgZXhwZXJpZW5jZVllYXI6IG51bWJlcjtcclxuICBhZG1pbkZpcnN0TmFtZTogc3RyaW5nO1xyXG4gIGFkbWluTGFzdE5hbWU6IHN0cmluZztcclxuICBhZG1pbkVtYWlsOiBzdHJpbmc7XHJcbiAgYWRtaW5QYXNzd29yZDogc3RyaW5nO1xyXG4gIGNpdHk6IHN0cmluZztcclxuICBkaXN0cmljdDogc3RyaW5nO1xyXG4gIGFkZHJlc3NMaW5lOiBzdHJpbmc7XHJcbiAgcG9zdGFsQ29kZT86IHN0cmluZztcclxufTtcclxuXHJcbnR5cGUgRW1wbG95ZWVSZWdpc3RyYXRpb24gPSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGVtYWlsOiBzdHJpbmc7XHJcbiAgcGFzc3dvcmQ6IHN0cmluZztcclxuICBwb3NpdGlvbjogc3RyaW5nO1xyXG4gIHBlcm1pc3Npb25zOiBzdHJpbmdbXTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXV0aENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IEF1dGhQcm92aWRlciA9ICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSA9PiB7XHJcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG5cclxuICAvLyBUb2tlbiBnZcOnZXJsaWxpxJ9pbmkga29udHJvbCBldFxyXG4gIGNvbnN0IGlzVG9rZW5WYWxpZCA9ICgpOiBib29sZWFuID0+IHtcclxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XHJcbiAgICBpZiAoIXRva2VuKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYXRvYih0b2tlbi5zcGxpdCgnLicpWzFdKSk7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcbiAgICAgIHJldHVybiBwYXlsb2FkLmV4cCA+IGN1cnJlbnRUaW1lO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBLdWxsYW7EsWPEsSBiaWxnaWxlcmluaSB0b2tlbidkYW4gw6fEsWthclxyXG4gIGNvbnN0IGdldFVzZXJGcm9tVG9rZW4gPSAodG9rZW46IHN0cmluZyk6IFVzZXIgfCBudWxsID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGF0b2IodG9rZW4uc3BsaXQoJy4nKVsxXSkpO1xyXG4gICAgICBjb25zb2xlLmxvZygnVG9rZW4gcGF5bG9hZDonLCBwYXlsb2FkKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFJvbGUgbWFwcGluZzogQmFja2VuZCdkZW4gZ2VsZW4gc2F5xLFzYWwgZGXEn2VybGVyaSBtYXAgZXRcclxuICAgICAgbGV0IHJvbGUgPSBwYXlsb2FkLnJvbGU7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdPcmlnaW5hbCByb2xlIGZyb20gdG9rZW46Jywgcm9sZSwgJ1R5cGU6JywgdHlwZW9mIHJvbGUpO1xyXG4gICAgICBcclxuICAgICAgLy8gSGVtIHNhecSxc2FsIGhlbSBzdHJpbmcgZGXEn2VybGVyaSBmcm9udGVuZCByb2wgaXNpbWxlcmluZSBtYXAgZXRcclxuICAgICAgc3dpdGNoIChyb2xlKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGNhc2UgJ1N1cGVyQWRtaW4nOlxyXG4gICAgICAgICAgcm9sZSA9ICdzdXBlci1hZG1pbic7ICAvLyBCYWNrZW5kOiBTdXBlckFkbWluPTEgdmV5YSAnU3VwZXJBZG1pbidcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICBjYXNlICdBZG1pbic6XHJcbiAgICAgICAgICByb2xlID0gJ2NvbXBhbnktYWRtaW4nOyAgLy8gQmFja2VuZDogQWRtaW49MiB2ZXlhICdBZG1pbidcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICBjYXNlICdVc2VyJzpcclxuICAgICAgICAgIHJvbGUgPSAnZW1wbG95ZWUnOyAgLy8gQmFja2VuZDogVXNlcj0zIHZleWEgJ1VzZXInXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcm9sZSA9ICd1bmtub3duJztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ01hcHBlZCByb2xlOicsIHJvbGUpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdXNlciA9IHtcclxuICAgICAgICBpZDogcGF5bG9hZC5uYW1laWQgfHwgcGF5bG9hZC5zdWIgfHwgcGF5bG9hZC51c2VySWQsXHJcbiAgICAgICAgbmFtZTogcGF5bG9hZC5uYW1lIHx8IChwYXlsb2FkLmdpdmVuX25hbWUgJiYgcGF5bG9hZC5mYW1pbHlfbmFtZSA/IHBheWxvYWQuZ2l2ZW5fbmFtZSArICcgJyArIHBheWxvYWQuZmFtaWx5X25hbWUgOiAnS3VsbGFuxLFjxLEnKSxcclxuICAgICAgICBlbWFpbDogcGF5bG9hZC5lbWFpbCxcclxuICAgICAgICByb2xlOiByb2xlLFxyXG4gICAgICAgIGNvbXBhbnlJZDogcGF5bG9hZC5jb21wYW55SWQsXHJcbiAgICAgICAgY29tcGFueU5hbWU6IHBheWxvYWQuY29tcGFueU5hbWUsXHJcbiAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXHJcbiAgICAgICAgcGVybWlzc2lvbnM6IHBheWxvYWQucGVybWlzc2lvbnMgPyBwYXlsb2FkLnBlcm1pc3Npb25zLnNwbGl0KCcsJykgOiBbXVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ0ZpbmFsIHVzZXIgb2JqZWN0OicsIHVzZXIpO1xyXG4gICAgICByZXR1cm4gdXNlcjtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgdG9rZW46JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBSZWZyZXNoIHRva2VuIGlsZSB5ZW5pIGFjY2VzcyB0b2tlbiBhbFxyXG4gIGNvbnN0IHJlZnJlc2hUb2tlbiA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcclxuICAgIGNvbnN0IHJlZnJlc2hUb2tlblZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgaWYgKCFyZWZyZXNoVG9rZW5WYWx1ZSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo1MDcxL2FwaSd9L0F1dGgvUmVmcmVzaFRva2VuYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlZnJlc2hUb2tlbjogcmVmcmVzaFRva2VuVmFsdWUgfSlcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhY2Nlc3NUb2tlbicsIGRhdGEuZGF0YS5hY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlZnJlc2hUb2tlbicsIGRhdGEuZGF0YS5yZWZyZXNoVG9rZW4pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHVzZXJEYXRhID0gZ2V0VXNlckZyb21Ub2tlbihkYXRhLmRhdGEuYWNjZXNzVG9rZW4pO1xyXG4gICAgICAgIGlmICh1c2VyRGF0YSkge1xyXG4gICAgICAgICAgc2V0VXNlcih1c2VyRGF0YSk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGluaXRBdXRoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgaWYgKGlzVG9rZW5WYWxpZCgpKSB7XHJcbiAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IGdldFVzZXJGcm9tVG9rZW4odG9rZW4pO1xyXG4gICAgICAgICAgaWYgKHVzZXJEYXRhKSB7XHJcbiAgICAgICAgICAgIHNldFVzZXIodXNlckRhdGEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBUb2tlbiBzw7xyZXNpIGRvbG11xZ8sIHJlZnJlc2ggdG9rZW4gZGVuZVxyXG4gICAgICAgICAgY29uc3QgcmVmcmVzaGVkID0gYXdhaXQgcmVmcmVzaFRva2VuKCk7XHJcbiAgICAgICAgICBpZiAoIXJlZnJlc2hlZCkge1xyXG4gICAgICAgICAgICAvLyBSZWZyZXNoIHRva2VuIGRhIGJhxZ9hcsSxc8SxeiwgbG9nb3V0IHlhcFxyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWNjZXNzVG9rZW4nKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICAgICAgICByb3V0ZXIucHVzaCgnL2F1dGgvbG9naW4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbml0QXV0aCgpO1xyXG4gIH0sIFtyb3V0ZXJdKTtcclxuXHJcbiAgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEFQSSd5ZSBsb2dpbiBpc3RlxJ9pIGfDtm5kZXJcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2dpblVzZXIoZW1haWwsIHBhc3N3b3JkKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChyZXNwb25zZS5pc1N1Y2Nlc3MgJiYgcmVzcG9uc2UuYWNjZXNzVG9rZW4gJiYgcmVzcG9uc2UucmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgLy8gVG9rZW4nbGFyxLEgbG9jYWxTdG9yYWdlJ2Ega2F5ZGV0XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FjY2Vzc1Rva2VuJywgcmVzcG9uc2UuYWNjZXNzVG9rZW4pO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyZWZyZXNoVG9rZW4nLCByZXNwb25zZS5yZWZyZXNoVG9rZW4pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRva2VuJ2RhbiBrdWxsYW7EsWPEsSBiaWxnaWxlcmluaSDDp8Sxa2FyXHJcbiAgICAgICAgY29uc3QgdXNlckRhdGEgPSBnZXRVc2VyRnJvbVRva2VuKHJlc3BvbnNlLmFjY2Vzc1Rva2VuKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodXNlckRhdGEpIHtcclxuICAgICAgICAgIHNldFVzZXIodXNlckRhdGEpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBSb2xlIGJhc2VkIHJvdXRpbmdcclxuICAgICAgICAgIHN3aXRjaCAodXNlckRhdGEucm9sZSkge1xyXG4gICAgICAgICAgICBjYXNlICdzdXBlci1hZG1pbic6XHJcbiAgICAgICAgICAgICAgcm91dGVyLnB1c2goJy9hZG1pbi9kYXNoYm9hcmQnKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY29tcGFueS1hZG1pbic6XHJcbiAgICAgICAgICAgICAgcm91dGVyLnB1c2goJy9jb21wYW55LWFkbWluL2Rhc2hib2FyZCcpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdlbXBsb3llZSc6XHJcbiAgICAgICAgICAgICAgcm91dGVyLnB1c2goJy9lbXBsb3llZS9kYXNoYm9hcmQnKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndW5rbm93bic6XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYW7EsW1sYW5tYW3EscWfIGt1bGxhbsSxY8SxIHJvbMO8LiBMw7x0ZmVuIHNpc3RlbSB5w7ZuZXRpY2lzaSBpbGUgaWxldGnFn2ltZSBnZcOnaW4uJyk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZcOnZXJzaXoga3VsbGFuxLFjxLEgcm9sw7w6ICR7dXNlckRhdGEucm9sZX1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLdWxsYW7EsWPEsSBiaWxnaWxlcmkgYWzEsW5hbWFkxLEnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLm1lc3NhZ2UgfHwgJ0dpcmnFnyBiYcWfYXLEsXPEsXonKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdHaXJpxZ8gc8SxcmFzxLFuZGEgYmlyIGhhdGEgb2x1xZ90dScpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbG9nb3V0ID0gKCkgPT4ge1xyXG4gICAgc2V0VXNlcihudWxsKTtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhY2Nlc3NUb2tlbicpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgcm91dGVyLnB1c2goJy9hdXRoL2xvZ2luJyk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcmVnaXN0ZXJDb21wYW55ID0gYXN5bmMgKGNvbXBhbnlEYXRhOiBDb21wYW55UmVnaXN0cmF0aW9uKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWdpc3RlckNvbXBhbnlBUEkoY29tcGFueURhdGEpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnxZ5pcmtldCBrYXlkxLEgc8SxcmFzxLFuZGEgYmlyIGhhdGEgb2x1xZ90dScpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGFkZEVtcGxveWVlID0gYXN5bmMgKGVtcGxveWVlRGF0YTogRW1wbG95ZWVSZWdpc3RyYXRpb24pID0+IHtcclxuICAgIC8vIE1vY2sgZW1wbG95ZWUgcmVnaXN0cmF0aW9uXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBpZiAoIXVzZXIgfHwgdXNlci5yb2xlICE9PSAnY29tcGFueS1hZG1pbicpIHtcclxuICAgICAgICByZWplY3QobmV3IEVycm9yKCfDh2FsxLHFn2FuIGVrbGVtZSB5ZXRraXNpIHlvaycpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5ld0VtcGxveWVlID0ge1xyXG4gICAgICAgICAgaWQ6IGBlbXAtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgICBuYW1lOiBlbXBsb3llZURhdGEubmFtZSxcclxuICAgICAgICAgIGVtYWlsOiBlbXBsb3llZURhdGEuZW1haWwsXHJcbiAgICAgICAgICByb2xlOiAnZW1wbG95ZWUnLFxyXG4gICAgICAgICAgY29tcGFueUlkOiB1c2VyLmNvbXBhbnlJZCxcclxuICAgICAgICAgIGNvbXBhbnlOYW1lOiB1c2VyLmNvbXBhbnlOYW1lLFxyXG4gICAgICAgICAgcG9zaXRpb246IGVtcGxveWVlRGF0YS5wb3NpdGlvbixcclxuICAgICAgICAgIHBlcm1pc3Npb25zOiBlbXBsb3llZURhdGEucGVybWlzc2lvbnMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zb2xlLmxvZygnw4dhbMSxxZ9hbiBla2xlbmRpOicsIG5ld0VtcGxveWVlKTtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH0sIDE1MDApO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBcclxuICAgICAgdXNlciwgXHJcbiAgICAgIGxvZ2luLCBcclxuICAgICAgbG9nb3V0LCBcclxuICAgICAgcmVnaXN0ZXJDb21wYW55LCBcclxuICAgICAgYWRkRW1wbG95ZWUsXHJcbiAgICAgIGxvYWRpbmcsXHJcbiAgICAgIGlzVG9rZW5WYWxpZCxcclxuICAgICAgcmVmcmVzaFRva2VuXHJcbiAgICB9fT5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB7XHJcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xyXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xyXG4gIH1cclxuICByZXR1cm4gY29udGV4dDtcclxufTsiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJvdXRlciIsImxvZ2luVXNlciIsInJlZ2lzdGVyQ29tcGFueSIsInJlZ2lzdGVyQ29tcGFueUFQSSIsIkF1dGhDb250ZXh0IiwidW5kZWZpbmVkIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VyIiwic2V0VXNlciIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwicm91dGVyIiwiaXNUb2tlblZhbGlkIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsImF0b2IiLCJzcGxpdCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImV4cCIsImdldFVzZXJGcm9tVG9rZW4iLCJjb25zb2xlIiwibG9nIiwicm9sZSIsImlkIiwibmFtZWlkIiwic3ViIiwidXNlcklkIiwibmFtZSIsImdpdmVuX25hbWUiLCJmYW1pbHlfbmFtZSIsImVtYWlsIiwiY29tcGFueUlkIiwiY29tcGFueU5hbWUiLCJwb3NpdGlvbiIsInBlcm1pc3Npb25zIiwiZXJyb3IiLCJyZWZyZXNoVG9rZW4iLCJyZWZyZXNoVG9rZW5WYWx1ZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5Iiwic3RyaW5naWZ5Iiwib2siLCJkYXRhIiwianNvbiIsInNldEl0ZW0iLCJhY2Nlc3NUb2tlbiIsInVzZXJEYXRhIiwiaW5pdEF1dGgiLCJyZWZyZXNoZWQiLCJyZW1vdmVJdGVtIiwicHVzaCIsImxvZ2luIiwicGFzc3dvcmQiLCJpc1N1Y2Nlc3MiLCJFcnJvciIsIm1lc3NhZ2UiLCJsb2dvdXQiLCJjb21wYW55RGF0YSIsInJlc3VsdCIsImFkZEVtcGxveWVlIiwiZW1wbG95ZWVEYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwibmV3RW1wbG95ZWUiLCJQcm92aWRlciIsInZhbHVlIiwidXNlQXV0aCIsImNvbnRleHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/AuthContext.tsx\n"));

/***/ })

});